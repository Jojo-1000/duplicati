import { Injectable } from "@angular/core";
import { AddOrUpdateBackupData } from "../backup";
import { BackupOptions } from "../edit-backup/backup-options";
import { DialogService } from "../services/dialog.service";
import { BackupChecker, RejectToStep } from "../services/edit-backup.service";
import { ParserService } from "../services/parser.service";
import { PassphraseService } from "../services/passphrase.service";
import { SystemInfoService } from "../system-info/system-info.service";

@Injectable()
export class CheckForMatchingPassphrase implements BackupChecker {
  constructor(private dialog: DialogService,
    private passphrase: PassphraseService) { }

  check(b: AddOrUpdateBackupData, opt: BackupOptions): Promise<void> {
    if (opt.encryptionModule.length > 0 && !this.passphrase.checkGpgAsymmetric(opt.encryptionModule, opt.extendedOptions)) {
      if (opt.passphrase.length == 0) {
        this.dialog.dialog($localize`Missing passphrase`,
          $localize`You must enter a passphrase or disable encryption`);
        return Promise.reject(new RejectToStep(0));
      }
      if (opt.passphrase !== opt.repeatPassphrase) {
        this.dialog.dialog($localize`Non-matching passphrase`,
          $localize`Passphrases are not matching`);
        return Promise.reject(new RejectToStep(0));
      }
    }
    return Promise.resolve();
  }
}

@Injectable()
export class CheckForGeneratedPassphrase implements BackupChecker {
  constructor(private dialog: DialogService) { }

  check(b: AddOrUpdateBackupData, opt: BackupOptions): Promise<void> {
    if (!opt.isNew) {
      return Promise.resolve();
    }
    if (opt.hasGeneratedPassphrase && opt.encryptionModule.length > 0) {
      return new Promise<void>((resolve, reject) => {
        this.dialog.dialog($localize`Autogenerated passphrase`,
          $localize`You have generated a strong passphrase. Make sure you have made a safe copy of the passphrase, as the data cannot be recovered if you lose the passphrase.`,
          [$localize`Cancel`, $localize`Yes, I have stored the passphrase safely`],
          (ix) => {
            if (ix === 0) {
              reject(new RejectToStep(0));
            } else {
              // Don't ask again
              opt.hasGeneratedPassphrase = false;
              resolve();
            }
          });
      });
    }
    return Promise.resolve();
  }
}

@Injectable()
export class CheckForChangedPassphrase implements BackupChecker {
  constructor(private dialog: DialogService,
    private parser: ParserService) { }

  check(b: AddOrUpdateBackupData, opt: BackupOptions): Promise<void> {
    if (opt.isNew) {
      return Promise.resolve();
    }
    // TODO: this won't work
    const prevEncryptionOpt = b.Backup.Settings.find(s => s.Name === '--no-encryption');
    const prevPassphraseOpt = b.Backup.Settings.find(s => s.Name === 'passphrase');
    const prevEncryptionModuleOpt = b.Backup.Settings.find(s => s.Name === 'encryption-module');

    const prevPassphrase = prevPassphraseOpt?.Value;
    const prevEncryptionEnabled = !this.parser.parseBoolString(prevEncryptionOpt?.Value);
    const prevEncryptionModule = !prevEncryptionEnabled ? '' : (prevEncryptionModuleOpt?.Value || '');

    const encryptionEnabled = opt.encryptionModule !== '';
    if (encryptionEnabled && prevEncryptionEnabled && prevPassphrase !== opt.passphrase) {
      return new Promise((resolve, reject) => {
        this.dialog.dialog($localize`Passphrase changed`,
          $localize`You have changed the passphrase, which is not supported. You are encouraged to create a new backup instead.`,
          [$localize`Cancel`, $localize`Yes, please break my backup!`],
          (ix) => {
            if (ix === 0) {
              reject(new RejectToStep(0));
            } else {
              resolve();
            }
          });
      });
    } else if (encryptionEnabled != prevEncryptionEnabled || opt.encryptionModule !== prevEncryptionModule) {
      return new Promise((resolve, reject) => {
        this.dialog.dialog($localize`Encryption changed`,
          $localize`You have changed the encryption mode. This may break stuff. You are encouraged to create a new backup instead`,
          [$localize`Cancel`, $localize`Yes, I'm brave!`],
          (ix) => {
            if (ix == 1) {
              resolve();
            } else {
              reject();
            }
          });
      });
    } else {
      return Promise.resolve();
    }
  }
}

@Injectable()
export class CheckForDisabledEncryption implements BackupChecker {
  private hasAnyEncryptionModules: boolean = true;

  constructor(private dialog: DialogService,
    private systemInfoService: SystemInfoService) {
    this.systemInfoService.getState().subscribe(info => this.hasAnyEncryptionModules = info.EncryptionModules.length > 0);
  }

  check(b: AddOrUpdateBackupData, opt: BackupOptions): Promise<void> {
    if (opt.encryptionModule != '' || b.Backup.TargetURL.startsWith('file://') || !this.hasAnyEncryptionModules) {
      return Promise.resolve();
    } else {
      return new Promise((resolve, reject) => {
        this.dialog.dialog($localize`No encryption`,
          $localize`You have chosen not to encrypt the backup. Encryption is recommended for all data stored on a remote server.`,
          [$localize`Cancel`, $localize`Continue without encryption`],
          (ix) => {
            if (ix === 0) {
              reject(new RejectToStep(0));
            } else {
              resolve();
            }
          });
      });
    }
  }

}

@Injectable()
export class WarnWeakPassphrase implements BackupChecker {
  constructor(private dialog: DialogService,
    private passphraseService: PassphraseService) { }


  check(b: AddOrUpdateBackupData, opt: BackupOptions): Promise<void> {
    if (!opt.isNew) {
      return Promise.resolve();
    }
    if (opt.encryptionModule != '') {
      const strength = this.passphraseService.computeStrength(opt.passphrase);
      if (strength <= 2) {
        return new Promise((resolve, reject) => {
          this.dialog.dialog($localize`Weak passphrase`,
            $localize`Your passphrase is easy to guess. Consider changing passphrase.`,
            [$localize`Cancel`, $localize`Use weak passphrase`],
            (ix) => {
              if (ix == 0) {
                reject(new RejectToStep(0));
              } else {
                resolve();
              }
            }
          )
        });
      }
    }
    return Promise.resolve();
  }
}
